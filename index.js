const gulp = require('gulp');
const through = require('through2');
const pluginError = require('plugin-error');
const typeOf = require('type-of');
const fancyLog = require('fancy-log');
const babylon = require('babylon');

const fs = require('fs');
const path = require('path');

const PLUGIN_NAME = 'gulp-inline-import';
const DEFAULT_MAX_ROUNDS = 3;
const DEFAULT_VERBOSE_STATE = false;

function noMoreImportStatements(plugin_name, file_content, verbose_mode) {
	let no_import_statements_found = true;

	const PARSED_CONTENT = babylon.parse(file_content, {
		sourceType: 'module'
	});

	if( PARSED_CONTENT.type === 'File' ) {
		if( PARSED_CONTENT.program.type === 'Program' ) {
			PARSED_CONTENT_BODY = PARSED_CONTENT.program.body;

			for( let part of PARSED_CONTENT_BODY ) {
				if( part.type === 'ImportDeclaration' ) {
					no_import_statements_found = false;

					break;
				}
			}
		}
	}

	return no_import_statements_found;
}

function isDefaultImportStatement(part) {
	return part.specifiers.length === 0;
}

function removeExportDefaultStatements(file_path, file_name, file_content) {
	let cleaned_content = file_content;

	const PARSED_CONTENT = babylon.parse(file_content, {
		sourceType: 'module'
	});

	if( PARSED_CONTENT.type === 'File' ) {
		if( PARSED_CONTENT.program.type === 'Program' ) {
			const PARSED_CONTENT_BODY = PARSED_CONTENT.program.body;

			for( let part of PARSED_CONTENT_BODY ) {
				if( part.type === 'ExportDefaultDeclaration' ) {
					if( part.declaration.type === 'Identifier' ) {
						cleaned_content = file_content.substring(0, part.start) + file_content.substring(part.end);
					}
					else {
						console.log(new pluginError(PLUGIN_NAME, 'export default statement in "' + file_name + '" declared as "' + part.declaration.type + '" not supported yet (please fill an issue)').toString());
					}
				}
			}
		}
	}

	return cleaned_content;
}

function traverse(file_path, file_name, file_content, verbose_mode) {
	if( noMoreImportStatements(PLUGIN_NAME, file_content, verbose_mode) === true ) {
		file_content_without_export_statements = removeExportDefaultStatements(file_path, file_name, file_content);

		fancyLog.info(PLUGIN_NAME + ': no more import statements in ' + file_name);

		return file_content_without_export_statements;
	}
	else {
		let cleaned_file_content = file_content;
		let decay = 0;

		const PARSED_CONTENT = babylon.parse(file_content, {
			sourceType: 'module'
		});

		if( PARSED_CONTENT.type === 'File' ) {
			if( PARSED_CONTENT.program.type === 'Program' ) {
				const PARSED_CONTENT_BODY = PARSED_CONTENT.program.body;

				for( let part of PARSED_CONTENT_BODY ) {
					if( part.type === 'ImportDeclaration' ) {
						if( isDefaultImportStatement(part) === true ) {
							if( part.source.type === 'StringLiteral' ) {
								try {
									const IMPORTED_FILE_PATH = file_path + '/' + part.source.value;
									const IMPORTED_FILE_NAME = path.basename(IMPORTED_FILE_PATH);
									const IMPORTED_FILE_CONTENT = fs.readFileSync(IMPORTED_FILE_PATH).toString();

									if( verbose_mode === true ) {
										fancyLog.info(PLUGIN_NAME + ': import statement found in ' + file_name);
										fancyLog.info(PLUGIN_NAME + ': searching for imports to include in ' + IMPORTED_FILE_NAME);
									}

									const cleaned_imported_file_content = traverse(path.dirname(IMPORTED_FILE_PATH), IMPORTED_FILE_NAME, IMPORTED_FILE_CONTENT, verbose_mode);

									cleaned_file_content = cleaned_file_content.substring(0, (part.start + decay)) + cleaned_imported_file_content + cleaned_file_content.substring(part.end + decay);

									decay = (cleaned_imported_file_content.length - (part.end - part.start)) - decay;
								}
								catch ( error ) {
									if( verbose_mode === true ) {
										// file not found
									}
								}
							}
							else {
								if( verbose_mode === true ) {
									// log error part.source.type not supported
								}
							}
						}
					}
				}
			}
		}

		return cleaned_file_content;
	}
}

/**
 * Gulp plugin to inline import from other files.
 * It avoid having some code that relate to ES6 import system, like the output generated by Browserify.
 */ 
function inlineImport(options = { verbose: DEFAULT_VERBOSE_STATE, maxDepth: DEFAULT_MAX_ROUNDS }) {
	if(options !== undefined && ('verbose' in options) === true && typeOf(options.verbose) !== 'boolean') {
		throw new pluginError(PLUGIN_NAME, 'option verbose should be a boolean, ' + typeOf(options.verbose) + ' given');
	}

	if(options !== undefined && ('maxDepth' in options) === true && typeOf(options.maxDepth) !== 'number')  {
		throw new pluginError(PLUGIN_NAME, 'option maxDepth should be an integer, ' + typeOf(options.maxDepth) + ' given');
	}

	if(options !== undefined && ('verbose' in options) === false) {
		options.verbose = DEFAULT_VERBOSE_STATE;
	}

	if(options !== undefined && ('maxDepth' in options) === false) {
		options.maxDepth = DEFAULT_MAX_ROUNDS;
	}

	return through.obj(function(file, encryption, callback) {
		if(file.isNull() === true || file.isStream() === true) {
			return callback(error = null, file);
		}

		const FILE_PATH = path.dirname(file.path);

		let file_content = new Buffer(file.contents).toString();

		let parse = babylon.parse(file_content, {
			sourceType: 'module'
		});

		let body = [];
		const FILE_NAME = file.relative;

		const INLINED_FILE_CONTENT = traverse(FILE_PATH, FILE_NAME, file_content, options.verbose);

		file.contents = new Buffer(INLINED_FILE_CONTENT);

		callback(error = null, file);
	});
}

module.exports = inlineImport;