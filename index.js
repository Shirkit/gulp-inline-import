const gulp = require('gulp');
const through = require('through2');
const pluginError = require('plugin-error');
const typeOf = require('type-of');
const fancyLog = require('fancy-log');

const fs = require('fs');
const path = require('path');

const PLUGIN_NAME = 'gulp-inline-import';
const DEFAULT_MAX_ROUNDS = 3;
const DEFAULT_VERBOSE_STATE = false;

/**
 * Recursively fetch the import, so that nested imported are resolved as well
 * 
 * @param content String
 * @param encryption String
 * @param catch_import_statements RegExp
 * @param catch_export_statements RegExp
 * @param current_depth Integer
 * @param max_depth Integer
 * @return String
 */
function traverse(content, file_path, encryption, catch_import_statements, catch_export_statements, current_depth, max_depth) {
	let copy = content;
	let matches = catch_import_statements.exec(copy);

	if(matches === null || current_depth > max_depth) {
		return copy;
	}
	else {
		let import_path = '';
		let file_content = '';
		let full_path = '';

		while( matches !== null ) {
			import_path = matches[1];
			match = matches[0];
			full_path = file_path + '/' + import_path;

			file_content = fs.readFileSync(full_path, encryption, mode = 'r');

			file_content = file_content.replace(catch_export_statements, '');

			copy = copy.replace(match, file_content);

			matches = catch_import_statements.exec(copy);
		}

		current_depth++;

		return traverse(copy, file_path, encryption, catch_import_statements, catch_export_statements, current_depth);
	}
}

function replaceUnnamedImportsRecursively(file_path, file_content, max_depth, current_depth, verbose) {
	const CATCH_IMPORT = /(?:import[\s]+["'])([\w-_.\/]+)(?:["'][;]*)/g;
	const CATCH_EXPORT = /export[\s]+default[\s].*[;]*/;

	let content = file_content;
	let matches = CATCH_IMPORT.exec(content);

	if( matches === null ) {
		fancyLog.info(PLUGIN_NAME + ': no more import to match');

		return content;
	}
	else if( current_depth >= max_depth ) {
		fancyLog.warn(PLUGIN_NAME + ': max depth (' + max_depth + ') reached');

		return content;
	}
	else {
		let sub_file_path = ''
		let sub_file_content = '';
		let sub_file_full_path = '';

		while( matches !== null ) {
			sub_file_path = matches[1];
			sub_file_import_statement = matches[0];
			sub_file_full_path = file_path + '/' + sub_file_path;

			if( verbose === true ) {
				fancyLog.info(PLUGIN_NAME + ': matched ' + sub_file_path);
			}
			
			try {
				sub_file_content = fs.readFileSync(sub_file_full_path);
			}
			catch( exception ) {
				if( verbose === true ) {
					fancyLog.warn(PLUGIN_NAME + ': file ' + sub_file_full_path + ' do not exists');
				}
			}

			content = content.replace(sub_file_import_statement, sub_file_content);
			content = content.replace(CATCH_EXPORT, '');

			if( verbose === true ) {
				fancyLog.info(PLUGIN_NAME + ': content from ' + sub_file_path + ' included');
			}

			matches = CATCH_IMPORT.exec(content);
		}

		current_depth++;

		return replaceUnnamedImportsRecursively(file_path, content, max_depth, current_depth, verbose);
	}
}

/**
 * Replace unnamed import syntax like "import './cate.js'" by its content
 */
 function replaceUnnamedImports(file_path, file_content, max_depth, verbose) {
 	let current_depth = 0;

 	return replaceUnnamedImportsRecursively(file_path, file_content, max_depth, current_depth, verbose);
 }

/**
 * Gulp plugin to inline import from other files.
 * It avoid having some code that relate to ES6 import system, like the output generated by Browserify.
 */ 
function inlineImport(options = { verbose: DEFAULT_VERBOSE_STATE, maxDepth: DEFAULT_MAX_ROUNDS }) {
	if(options !== undefined && ('verbose' in options) === true && typeOf(options.verbose) !== 'boolean') {
		throw new pluginError(PLUGIN_NAME, 'option verbose should be a boolean, ' + typeOf(options.verbose) + ' given');
	}

	if(options !== undefined && ('maxDepth' in options) === true && typeOf(options.maxDepth) !== 'number')  {
		throw new pluginError(PLUGIN_NAME, 'option maxDepth should be an integer, ' + typeOf(options.maxDepth) + ' given');
	}

	if(options !== undefined && ('verbose' in options) === false) {
		options.verbose = DEFAULT_VERBOSE_STATE;
	}

	if(options !== undefined && ('maxDepth' in options) === false) {
		options.maxDepth = DEFAULT_MAX_ROUNDS;
	}

	return through.obj(function(file, encryption, callback) {
		if(file.isNull() === true || file.isStream() === true) {
			return callback(error = null, file);
		}

		const FILE_PATH = path.dirname(file.path);

		let file_content = new Buffer(file.contents).toString();

		let inlined_file_content = replaceUnnamedImports(FILE_PATH, file_content, options.maxDepth, options.verbose);

		file.contents = new Buffer(inlined_file_content);

		callback(error = null, file);
	});
}

module.exports = inlineImport;